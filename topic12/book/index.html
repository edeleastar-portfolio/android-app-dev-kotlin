<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="shortcut icon" href="favicon.ico" type="image/x-icon">
  <link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.2.10/semantic.min.css"
        type="text/css">
  <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/railscasts.min.css"
        rel="stylesheet"/>
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
  <script type="text/javascript"
          src="https://cdnjs.cloudflare.com/ajax/libs/jquery.address/1.6/jquery.address.min.js"></script>
  <script type="text/javascript"
          src="https://cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.2.10/semantic.min.js"></script>
  <script type="text/javascript"
          src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script type="text/javascript"
          src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/java.min.js"></script>
  <script type="text/javascript"
          src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/kotlin.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
  <style>
    

body {
  font-family: "Open Sans", "Helvetica", "Helvetica Neue",  "Arial", sans-serif;
  font-size:90%;
  color: black;
}

p {
  margin: 0.5em;
}

pre code {
  font-family: "Monaco";
  font-size: 100%;
}

img {
  box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19);
  margin:10px;
}

h1, h2, h3 {
  border-bottom:thin solid black;
  margin-bottom: 0.5em;
  margin-top: 1em;
}

h1 {
  font-style:italic;
  font-size:130%;
}

h2 {
  font-size:110%;
}

h3 {
  font-size:100%;
}



  </style>
</head>

<body>



<div class="ui fixed top pointing inverted stackable menu labmenu">
  <header class="header item">
    <i id="toc" class="sitemap icon"></i>
    
      <a href="../index.html"> Firebase Database + Storage  </a>
    
  </header>
  <div class="right tab-menu menu">
    
      <a class="item" data-tab="Lab-12">
        Lab-12
      </a>
    
      <a class="item" data-tab="Solutions">
        Solutions
      </a>
    
      <a class="item" data-tab="02">
        02
      </a>
    
      <a class="item" data-tab="03">
        03
      </a>
    
      <a class="item" data-tab="04">
        04
      </a>
    
      <a class="item" data-tab="05">
        05
      </a>
    
      <a class="item" data-tab="06">
        06
      </a>
    
      <a class="item" data-tab="07">
        07
      </a>
    
      <a class="item" data-tab="Exercises">
        Exercises
      </a>
    
  </div>
</div>

<div class="ui pushable">
  <div class="ui inverted labeled icon left inline vertical sidebar menu">
    <br><br>
    
      
        <a class="item"
           href="https://edeleastar-portfolio.github.io/android-app-dev-kotlin//topic01/book-1/index.html">Lab-01 </a>
      
    
      
        <a class="item"
           href="https://edeleastar-portfolio.github.io/android-app-dev-kotlin//topic02/book/index.html">Lab-02 </a>
      
    
      
        <a class="item"
           href="https://edeleastar-portfolio.github.io/android-app-dev-kotlin//topic03/book/index.html">Lab-03 </a>
      
    
      
        <a class="item"
           href="https://edeleastar-portfolio.github.io/android-app-dev-kotlin//topic04/book/index.html">Lab-04 </a>
      
    
      
        <a class="item"
           href="https://edeleastar-portfolio.github.io/android-app-dev-kotlin//topic05/book/index.html">Lab-05 </a>
      
    
      
        <a class="item"
           href="https://edeleastar-portfolio.github.io/android-app-dev-kotlin//topic06/book/index.html">Lab-06 </a>
      
    
      
        <a class="item"
           href="https://edeleastar-portfolio.github.io/android-app-dev-kotlin//topic07/book/index.html">Lab-07 </a>
      
    
      
        <a class="item"
           href="https://edeleastar-portfolio.github.io/android-app-dev-kotlin//topic08/book/index.html">Lab-08 </a>
      
    
      
        <a class="item"
           href="https://edeleastar-portfolio.github.io/android-app-dev-kotlin//topic09/book/index.html">Lab-09 </a>
      
    
      
        <a class="item"
           href="https://edeleastar-portfolio.github.io/android-app-dev-kotlin//topic10/book/index.html">Lab-10 </a>
      
    
      
        <a class="item"
           href="https://edeleastar-portfolio.github.io/android-app-dev-kotlin//topic11/book/index.html">Lab-11 </a>
      
    
      
        <a class="item"
           href="https://edeleastar-portfolio.github.io/android-app-dev-kotlin//topic12/book/index.html">Lab-12 </a>
      
    
  </div>
  <div class="pusher" tabindex="-1">
    <div class="ui basic segment">
      <br>
      
        <div class="ui tab segment lab" data-tab="Lab-12">
          <h1>Objectives</h1>
<p>Store placemarks in Firebase Realtime Database + images in Firebase Storage</p>

        </div>
      
        <div class="ui tab segment lab" data-tab="Solutions">
          <h1>Solutions</h1>
<h1>Exercise 1</h1>
<p>Adjust the title of the PlacemarkListActivity - such that it displays the logged in users email:</p>
<p><img src="img/13.png" alt=""></p>
<p>The logged in user details are reasonably easy to locate:</p>
<ul>
<li><a href="https://firebase.google.com/docs/auth/web/manage-users">https://firebase.google.com/docs/auth/web/manage-users</a></li>
</ul>
<p>Here is how we could access this in kotlin:</p>
<pre><code>    val user = FirebaseAuth.getInstance().currentUser
    var appTitle = &quot;${title.toString()}: ${user!!.email}&quot;</code></pre>
<h2>Solution</h2>
<h2>PlacemarkListActivity</h2>
<p>In onCreate - we can extend the title as follows:</p>
<pre><code>...
    val user = FirebaseAuth.getInstance().currentUser
    var appTitle = &quot;${title.toString()}: ${user!!.email}&quot;
    toolbarMain.title = appTitle
    setSupportActionBar(toolbarMain)
...</code></pre>

        </div>
      
        <div class="ui tab segment lab" data-tab="02">
          <h2>Versions</h2>
<p>Firstly, we will bump all versions - including moving the SDK 27. This will download quite a range of new artifacts when you trigger it.</p>
<p>Additionally, we include three new library components:</p>
<ul>
<li>implementation &quot;com.google.firebase:firebase-database:$firebase_version&quot;</li>
<li>implementation &quot;com.google.firebase:firebase-storage:$firebase_version&quot;</li>
<li>implementation &quot;com.github.bumptech.glide:glide:$glide_version&quot;</li>
</ul>
<p>The first two are the firebase database (for the placemakrs themselves) and firebase storage (for the placemark images). The last is a new library we need for working with images when they may be stored remotely.</p>
<p>Below are the complete grade files:</p>
<h2>build.gradle (top level)</h2>
<pre><code>buildscript {
  ext.kotlin_version = &#39;1.2.31&#39;
  ext.google_services_version = &#39;3.1.1&#39;

  ext.app_compat_version = &#39;27.1.1&#39;
  ext.design_library_version = &#39;27.1.1&#39;
  ext.support_library_version = &#39;27.1.1&#39;
  ext.cardview_library_version = &#39;27.1.1&#39;
  ext.constraint_layout_version = &#39;1.0.2&#39;

  ext.anko_version = &#39;0.10.4&#39;
  ext.anko_commons_version = &#39;0.10.4&#39;

  ext.play_services_maps_version = &#39;12.0.1&#39;
  ext.play_services_location_version = &#39;12.0.1&#39;
  ext.firebase_version = &#39;12.0.1&#39;

  ext.room_version = &#39;1.0.0&#39;

  ext.glide_version = &#39;4.7.1&#39;

  repositories {
    google()
    jcenter()
  }
  dependencies {
    classpath &#39;com.android.tools.build:gradle:3.1.1&#39;
    classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot;
    classpath &quot;com.google.gms:google-services:$google_services_version&quot;
  }
}

allprojects {
  repositories {
    google()
    jcenter()
  }
}

task clean(type: Delete) {
  delete rootProject.buildDir
}</code></pre>
<h2>build.gradle</h2>
<pre><code>apply plugin: &#39;com.android.application&#39;
apply plugin: &#39;kotlin-android&#39;
apply plugin: &#39;kotlin-android-extensions&#39;
apply plugin: &quot;kotlin-kapt&quot;

android {
  compileSdkVersion 27
  defaultConfig {
    applicationId &quot;org.wit.placemark&quot;
    minSdkVersion 23
    targetSdkVersion 27
    versionCode 1
    versionName &quot;1.0&quot;
    testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot;
  }
  buildTypes {
    release {
      minifyEnabled false
      proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39;
    }
  }
}

androidExtensions {
  experimental = true
}

dependencies {
  implementation fileTree(dir: &#39;libs&#39;, include: [&#39;*.jar&#39;])
  implementation &quot;org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version&quot;

  implementation &quot;com.android.support:appcompat-v7:$app_compat_version&quot;
  implementation &quot;com.android.support.constraint:constraint-layout:$constraint_layout_version&quot;
  implementation &quot;com.android.support:design:$design_library_version&quot;
  implementation &quot;com.android.support:cardview-v7:$cardview_library_version&quot;

  implementation &quot;org.jetbrains.anko:anko:$anko_version&quot;
  implementation &quot;org.jetbrains.anko:anko-commons:$anko_commons_version&quot;

  implementation &quot;com.google.android.gms:play-services-maps:$play_services_maps_version&quot;
  implementation &quot;com.google.android.gms:play-services-location:$play_services_location_version&quot;

  implementation &quot;android.arch.persistence.room:runtime:$room_version&quot;
  implementation &quot;com.google.firebase:firebase-auth:$firebase_version&quot;
  implementation &quot;com.google.firebase:firebase-database:$firebase_version&quot;
  implementation &quot;com.google.firebase:firebase-storage:$firebase_version&quot;

  implementation &quot;com.github.bumptech.glide:glide:$glide_version&quot;

  annotationProcessor &quot;android.arch.persistence.room:compiler:$room_version&quot;
  kapt &quot;android.arch.persistence.room:compiler:$room_version&quot;

  testImplementation &#39;junit:junit:4.12&#39;
  androidTestImplementation &#39;com.android.support.test:runner:1.0.1&#39;
  androidTestImplementation &#39;com.android.support.test.espresso:espresso-core:3.0.1&#39;
}

apply plugin: &#39;com.google.gms.google-services&#39;</code></pre>
<p>These upgrades will require one change due to an shift in the API signatures</p>
<h2>PlacemarkAdapter</h2>
<p>Replace this:</p>
<pre><code>  override fun onCreateViewHolder(parent: ViewGroup?, viewType: Int): MainHolder {</code></pre>
<p>with this:</p>
<pre><code>  override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): MainHolder {</code></pre>
<p>This change is inconsequential for our app - but is necessary for it to build.</p>

        </div>
      
        <div class="ui tab segment lab" data-tab="03">
          <h1>Preparing for Firebase</h1>
<p>We need to make a number of small changes to the application in order to prepare for incorporating Firebase storage of placemarks.</p>
<h1>Managing the Firebase ID</h1>
<p>In PlacemarkModel, we need an additional ID - fbId - to record the Firebase ID of each placemark. Unlike the existing id, which is a Long, the firebase id is a string:</p>
<h2>PlacemarkModel</h2>
<pre><code>data class PlacemarkModel(@PrimaryKey(autoGenerate = true) var id: Long = 0,
                          var fbId : String = &quot;&quot;,
                          var title: String = &quot;&quot;,
                          var description: String = &quot;&quot;,
                          var image: String = &quot;&quot;,
                          var lat : Double = 0.0,
                          var lng: Double = 0.0,
                          var zoom: Float = 0f) : Parcelable</code></pre>
<p>The id field (the Long one) is used in the PlacemarksMapsActivity to track user interaction with the markers on the map. As this id may be 0 when the placemarks are stored in Firebase, we need to change this.</p>
<h2>PlacemarkMapsActivity</h2>
<p>Locate this line:</p>
<pre><code>    map.addMarker(options).tag = it.id</code></pre>
<p>.. and replace with:</p>
<pre><code>    map.addMarker(options).tag = it</code></pre>
<p>Also, locate</p>
<pre><code>      val tag = marker.tag as Long
      val placemark = app.placemarks.findById(tag)</code></pre>
<p>and replace with</p>
<pre><code>    val placemark = marker.tag as PlacemarkModel</code></pre>
<p>In the above, we are using the entire placemark as the tag, not just the id.</p>
<h1>Clearing Placemarks between user logins</h1>
<p>As we are now supporting multiple logins - then we need a way of clearing the placemakrs between different users accessing the app.</p>
<h2>PlacemarkMemStore</h2>
<pre><code>  fun clear()</code></pre>
<h2>PlacemarkMemStore</h2>
<pre><code>  override fun clear() {
    placemarks.clear()
  }</code></pre>
<h2>PlacemarkStoreRoom</h2>
<pre><code>  override fun clear() {
  }</code></pre>
<p>We keep the PlacemarkStoreRoom implementation empty for the moment.</p>
<h1>Image Management</h1>
<p>Currently we load all of the images using a helper method we have written for this purpose. We will replace this now with the Glide library:</p>
<ul>
<li><a href="https://github.com/bumptech/glide">https://github.com/bumptech/glide</a></li>
</ul>
<p>This will work as as currently, but additionally it will also work with url of images on the public Internet. This will be part of our move to firebase later in this lab.</p>
<h2>PlacemarkAdapter</h2>
<p>Replace:</p>
<pre><code>      itemView.imageIcon.setImageBitmap(readImageFromPath(itemView.context, placemark.image))</code></pre>
<p>with</p>
<pre><code>      Glide.with(itemView.context).load(placemark.image).into(itemView.imageIcon);</code></pre>
<h2>PlacemarkActivity</h2>
<p>Replace:</p>
<pre><code>      placemarkImage.setImageBitmap(readImageFromPath(this, placemark.image))</code></pre>
<p>with:</p>
<pre><code>      Glide.with(this).load(placemark.image).into(placemarkImage);</code></pre>
<h2>PlacemarkMapsActivity</h2>
<p>Replace:</p>
<pre><code>      imageView.setImageBitmap(readImageFromPath(this@PlacemarkMapsActivity, placemark.image))</code></pre>
<p>with:</p>
<pre><code>      Glide.with(this@PlacemarkMapsActivity).load(placemark.image).into(imageView);</code></pre>

        </div>
      
        <div class="ui tab segment lab" data-tab="04">
          <h1>Firebase Database</h1>
<p>In your Firebase Application Console, select <code>Database</code>:</p>
<p><img src="img/01x.png" alt=""></p>
<p>And press <code>Get Started</code> on <code>Realtime Database</code>:</p>
<p><img src="img/02x.png" alt=""></p>
<p>Be sure to select <code>Start in test mode</code> as shown above.</p>
<p><img src="img/03x.png" alt=""></p>
<p>This is a view into your database - you will see in real time here any objects you insert. Also, take note of the url:</p>
<pre><code>https://placemark-XXXXd.firebaseio.co</code></pre>
<p>This will be used in your application configuration. To establish the connection, in Studio select <code>Tools-&gt;Firebase-&gt;Realtime Database</code></p>
<p><img src="img/04.png" alt=""></p>
<p>Press connect (screen shot above shows result of pressing connect). This is all you need to do at this stage. If you like, you can verify that the connection has been made. Do this by locating the following file:</p>
<ul>
<li>app/google-services.json</li>
</ul>
<p>It may look something like this:</p>
<pre><code>{
  &quot;project_info&quot;: {
    &quot;project_number&quot;: &quot;4283XXXXX&quot;,
    &quot;firebase_url&quot;: &quot;https://placemark-XXXXd.firebaseio.com&quot;,
    &quot;project_id&quot;: &quot;placemark-XXXd&quot;,
  },
  &quot;client&quot;: [
    {
      &quot;client_info&quot;: {
        &quot;mobilesdk_app_id&quot;: &quot;1:428338485028:android:634c4XXXce143&quot;,
        &quot;android_client_info&quot;: {
          &quot;package_name&quot;: &quot;org.wit.placemark&quot;
        }
      },
      &quot;oauth_client&quot;: [
        {
          &quot;client_id&quot;: &quot;4283XXXXX028-ntqXXXXXXXXXl9ot6ok3r.apps.googleusercontent.com&quot;,
          &quot;client_type&quot;: 1,
          &quot;android_info&quot;: {
            &quot;package_name&quot;: &quot;org.wit.placemark&quot;,
            &quot;certificate_hash&quot;: &quot;bcaa865ad78XXXXXXXXX731db4da8b&quot;
          }
        },
        {
          &quot;client_id&quot;: &quot;42833848XXXXXX5cup7XXXXXXk8s.apps.googleusercontent.com&quot;,
          &quot;client_type&quot;: 3
        }
      ],
      &quot;api_key&quot;: [
        {
          &quot;current_key&quot;: &quot;AIzaSyBXXXXXXXXXXXoTeWhTqfKxbI&quot;
        }
      ],
      &quot;services&quot;: {
        &quot;analytics_service&quot;: {
          &quot;status&quot;: 1
        },
        &quot;appinvite_service&quot;: {
          &quot;status&quot;: 2,
          &quot;other_platform_oauth_client&quot;: [
            {
              &quot;client_id&quot;: &quot;428338XXXXXXXXXXXXXXXXXX1e4kk8s.apps.googleusercontent.com&quot;,
              &quot;client_type&quot;: 3
            }
          ]
        },
        &quot;ads_service&quot;: {
          &quot;status&quot;: 2
        }
      }
    }
  ],
  &quot;configuration_version&quot;: &quot;1&quot;
}</code></pre>
<p>A Firebase URL should be in the opening info object.</p>

        </div>
      
        <div class="ui tab segment lab" data-tab="05">
          <h1>FireStore</h1>
<p>Create a new package called <code>org.wit.placemark.firebase</code>, and introduce this new class, an implementation of PlacemarkStore:</p>
<h3>PlacemarkFireStore</h3>
<pre><code>package org.wit.placemark.firebase

import android.content.Context
import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.database.*
import org.jetbrains.anko.AnkoLogger
import org.wit.placemark.models.PlacemarkModel
import org.wit.placemark.models.PlacemarkStore

class PlacemarkFireStore(val context: Context) : PlacemarkStore, AnkoLogger {

  val placemarks = ArrayList&lt;PlacemarkModel&gt;()
  lateinit var userId: String
  lateinit var db: DatabaseReference

  suspend override fun findAll(): List&lt;PlacemarkModel&gt; {
    return placemarks
  }

  suspend override fun findById(id: Long): PlacemarkModel? {
    val foundPlacemark: PlacemarkModel? = placemarks.find { p -&gt; p.id == id }
    return foundPlacemark
  }

  override fun create(placemark: PlacemarkModel) {
    val key = db.child(&quot;users&quot;).child(userId).child(&quot;placemarks&quot;).push().key
    placemark.fbId = key
    placemarks.add(placemark)
    db.child(&quot;users&quot;).child(userId).child(&quot;placemarks&quot;).child(key).setValue(placemark)
  }

  override fun update(placemark: PlacemarkModel) {
    var foundPlacemark: PlacemarkModel? = placemarks.find { p -&gt; p.fbId == placemark.fbId }
    if (foundPlacemark != null) {
      foundPlacemark.title = placemark.title
      foundPlacemark.description = placemark.description
      foundPlacemark.image = placemark.image
      foundPlacemark.lat = placemark.lat
      foundPlacemark.lng = placemark.lng
      foundPlacemark.zoom = placemark.zoom
    }

    db.child(&quot;users&quot;).child(userId).child(&quot;placemarks&quot;).child(placemark.fbId).setValue(placemark)
  }

  override fun delete(placemark: PlacemarkModel) {
    db.child(&quot;users&quot;).child(userId).child(&quot;placemarks&quot;).child(placemark.fbId).removeValue()
    placemarks.remove(placemark)
  }

  override fun clear() {
    placemarks.clear()
  }

  fun fetchPlacemarks(placemarksReady: () -&gt; Unit) {
    val valueEventListener = object : ValueEventListener {
      override fun onCancelled(dataSnapshot: DatabaseError?) {
      }
      override fun onDataChange(dataSnapshot: DataSnapshot?) {
        dataSnapshot!!.children.mapNotNullTo(placemarks) { it.getValue&lt;PlacemarkModel&gt;(PlacemarkModel::class.java) }
        placemarksReady()
      }
    }
    userId = FirebaseAuth.getInstance().currentUser!!.uid
    db = FirebaseDatabase.getInstance().reference
    placemarks.clear()
    db.child(&quot;users&quot;).child(userId).child(&quot;placemarks&quot;).addListenerForSingleValueEvent(valueEventListener)
  }
}</code></pre>
<p>This is an implementation of our PlacemarkStore interface - which stores/retrieves placemarks from the Firebase database.</p>
<p>It implements all the PlacemarkStore methods + one new method not specified in the interface:</p>
<pre><code>  fun fetchPlacemarks(placemarksReady: () -&gt; Unit) {
    val valueEventListener = object : ValueEventListener {
      override fun onCancelled(dataSnapshot: DatabaseError?) {
      }
      override fun onDataChange(dataSnapshot: DataSnapshot?) {
        dataSnapshot!!.children.mapNotNullTo(placemarks) { it.getValue&lt;PlacemarkModel&gt;(PlacemarkModel::class.java) }
        placemarksReady()
      }
    }
    userId = FirebaseAuth.getInstance().currentUser!!.uid
    db = FirebaseDatabase.getInstance().reference
    placemarks.clear()
    db.child(&quot;users&quot;).child(userId).child(&quot;placemarks&quot;).addListenerForSingleValueEvent(valueEventListener)
  }</code></pre>
<p>This is a method to fetch placemarks, and trigger a callback (placemarkReady) when the placemakrs have been retrieved. We will need to explicitly call this method when we are log in (next step).</p>

        </div>
      
        <div class="ui tab segment lab" data-tab="06">
          <h1>Login</h1>
<p>This is a revised Login activity:</p>
<h2>LoginActivity</h2>
<pre><code>package org.wit.placemark.activities

import android.os.Bundle
import android.support.v7.app.AppCompatActivity
import android.view.View
import com.google.firebase.auth.FirebaseAuth
import kotlinx.android.synthetic.main.activity_login.*
import org.jetbrains.anko.AnkoLogger
import org.jetbrains.anko.info
import org.jetbrains.anko.intentFor
import org.jetbrains.anko.toast
import org.wit.placemark.R
import org.wit.placemark.firebase.PlacemarkFireStore
import org.wit.placemark.main.MainApp

class LoginActivity : AppCompatActivity(), AnkoLogger {

  lateinit var auth: FirebaseAuth
  var fireStore: PlacemarkFireStore? = null

  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    setContentView(R.layout.activity_login)
    auth = FirebaseAuth.getInstance()

    var app = application as MainApp
    if (app.placemarks is PlacemarkFireStore) {
      fireStore = app.placemarks as PlacemarkFireStore
    }

    signUpBtn.setOnClickListener {
      val email = field_email.text.toString()
      val password = field_password.text.toString()
      if (email == &quot;&quot; || password == &quot;&quot;) {
        toast(&quot;Please provide email + password&quot;)
      }
      else {
        auth.createUserWithEmailAndPassword(email, password).addOnCompleteListener(this) { task -&gt;
          if (task.isSuccessful) {
            info(&quot;Login success&quot;)
            startActivity(intentFor&lt;PlacemarkListActivity&gt;())
          }
          else {
            toast(&quot;Sign Up Failed: ${task.exception?.message}&quot;)
          }
        }
      }
    }

    signInBtn.setOnClickListener {
      val email = field_email.text.toString()
      val password = field_password.text.toString()
      if (email == &quot;&quot; || password == &quot;&quot;) {
        toast(&quot;Please provide email + password&quot;)
      }
      else {
        auth.signInWithEmailAndPassword(email, password).addOnCompleteListener(this) { task -&gt;
          if (task.isSuccessful) {
            if (fireStore != null) {
              fireStore!!.fetchPlacemarks {
                startActivity(intentFor&lt;PlacemarkListActivity&gt;())
              }
            }
            else {
              startActivity(intentFor&lt;PlacemarkListActivity&gt;())
            }
          }
          else {
            toast(&quot;Sign In Failed&quot;)
          }
        }
      }
    }
  }
}</code></pre>
<p>The key here is the code dealing with a successful login:</p>
<pre><code>            if (fireStore != null) {
              fireStore!!.fetchPlacemarks {
                startActivity(intentFor&lt;PlacemarkListActivity&gt;())
              }
            }
            else {
              startActivity(intentFor&lt;PlacemarkListActivity&gt;())
            }
          }</code></pre>
<p>In the above, we are checking to see if we are using the fireStore PlacemarkStore implementation, and if so, we fetch the placemarks and will be notified when they arrive. If we are not using the fireStore, then we just launch PlacemarkListActivity as normal.</p>
<p>Create the PlacemarkFireStore now in MainApp:</p>
<pre><code>class MainApp : Application(), AnkoLogger {

  lateinit var placemarks: PlacemarkStore

  override fun onCreate() {
    super.onCreate()
    placemarks = PlacemarkFireStore(this)
    info(&quot;Placemark started&quot;)
  }
}</code></pre>
<p>Run the app now, log in and create some placemarks. </p>
<p>Keep an eye on the Database console:</p>
<p><img src="img/06.png" alt=""></p>
<p>You should see the placemarks you create populating here. Each users placemarks are grouped under the user id. And individual placemakrs are under their own unique id.</p>
<p>User Ids can be cross-referenced on the Authentication panel:</p>
<p><img src="img/07.png" alt=""></p>
<p>Experiment with various accounts + placemarks now. Verify that when you log in you get the placemarks relevant to the logged in user.</p>
<p>Also - note that the images are still stored locally. So, although they will display as normal - they will not be available if you change emulators. Perhaps try this now to verify that placemark images are localised to a specific phone.</p>

        </div>
      
        <div class="ui tab segment lab" data-tab="07">
          <h1>Firebase Storage</h1>
<p>Back in the Firebase Console, select <code>Storage</code>:</p>
<p><img src="img/02.png" alt=""></p>
<p><img src="img/03.png" alt=""></p>
<p>This gives a general purpose file storage area:</p>
<p><img src="img/05.png" alt=""></p>
<p>We will use this to store the placemark images.</p>
<p>In Studio, we now connect our app to the Firebase Storage system:</p>
<p><img src="img/08.png" alt=""></p>
<p>This will update an entry in the google-services.json file, connecting the app to the storeage system.</p>
<p>Here is a revised PlacemarkFireStore class, which also uploads the placemark images to the fire base storage:</p>
<pre><code>package org.wit.placemark.firebase

import android.content.Context
import android.graphics.Bitmap
import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.database.*
import com.google.firebase.storage.FirebaseStorage
import com.google.firebase.storage.StorageReference
import org.jetbrains.anko.AnkoLogger
import org.wit.placemark.helpers.readImageFromPath
import org.wit.placemark.models.PlacemarkModel
import org.wit.placemark.models.PlacemarkStore
import java.io.ByteArrayOutputStream
import java.io.File

class PlacemarkFireStore(val context: Context) : PlacemarkStore, AnkoLogger {

  val placemarks = ArrayList&lt;PlacemarkModel&gt;()
  lateinit var userId: String
  lateinit var db: DatabaseReference
  lateinit var st : StorageReference

  suspend override fun findAll(): List&lt;PlacemarkModel&gt; {
    return placemarks
  }

  suspend override fun findById(id: Long): PlacemarkModel? {
    val foundPlacemark: PlacemarkModel? = placemarks.find { p -&gt; p.id == id }
    return foundPlacemark
  }

  override fun create(placemark: PlacemarkModel) {
    val key = db.child(&quot;users&quot;).child(userId).child(&quot;placemarks&quot;).push().key
    placemark.fbId = key
    placemarks.add(placemark)
    db.child(&quot;users&quot;).child(userId).child(&quot;placemarks&quot;).child(key).setValue(placemark)
    updateImage(placemark)
  }

  override fun update(placemark: PlacemarkModel) {
    var foundPlacemark: PlacemarkModel? = placemarks.find { p -&gt; p.fbId == placemark.fbId }
    if (foundPlacemark != null) {
      foundPlacemark.title = placemark.title
      foundPlacemark.description = placemark.description
      foundPlacemark.image = placemark.image
      foundPlacemark.lat = placemark.lat
      foundPlacemark.lng = placemark.lng
      foundPlacemark.zoom = placemark.zoom
    }

    db.child(&quot;users&quot;).child(userId).child(&quot;placemarks&quot;).child(placemark.fbId).setValue(placemark)
    if ((placemark.image.length) &gt; 0 &amp;&amp; (placemark.image[0] != &#39;h&#39;)) {
      updateImage(placemark)
    }
  }

  override fun delete(placemark: PlacemarkModel) {
    db.child(&quot;users&quot;).child(userId).child(&quot;placemarks&quot;).child(placemark.fbId).removeValue()
    placemarks.remove(placemark)
  }

  override fun clear() {
    placemarks.clear()
  }

  fun updateImage(placemark: PlacemarkModel) {
    if (placemark.image != &quot;&quot;) {
      val fileName = File(placemark.image)
      val imageName = fileName.getName()

      val bitmap = readImageFromPath(context, placemark.image)
      var imageRef = st.child(userId + &#39;/&#39; + imageName)
      val baos = ByteArrayOutputStream()
      bitmap!!.compress(Bitmap.CompressFormat.JPEG, 100, baos)
      val data = baos.toByteArray()
      val uploadTask = imageRef.putBytes(data)
      uploadTask.addOnFailureListener {
        println (it.message)
      }.addOnSuccessListener { taskSnapshot -&gt;
        placemark.image = taskSnapshot.downloadUrl.toString()
        db.child(&quot;users&quot;).child(userId).child(&quot;placemarks&quot;).child(placemark.fbId).setValue(placemark)
      }
    }
  }

  fun fetchPlacemarks(placemarksReady: () -&gt; Unit) {
    val valueEventListener = object : ValueEventListener {
      override fun onCancelled(dataSnapshot: DatabaseError?) {
      }
      override fun onDataChange(dataSnapshot: DataSnapshot?) {
        dataSnapshot!!.children.mapNotNullTo(placemarks) { it.getValue&lt;PlacemarkModel&gt;(PlacemarkModel::class.java) }
        placemarksReady()
      }
    }
    userId = FirebaseAuth.getInstance().currentUser!!.uid
    db = FirebaseDatabase.getInstance().reference
    st = FirebaseStorage.getInstance().reference
    placemarks.clear()
    db.child(&quot;users&quot;).child(userId).child(&quot;placemarks&quot;).addListenerForSingleValueEvent(valueEventListener)
  }
}</code></pre>
<p>Try this now - add some images, and modify the Storage console to see if the images are appearing:</p>

        </div>
      
        <div class="ui tab segment lab" data-tab="Exercises">
          <h1>Solution</h1>
<p>Placemark application so far:</p>
<ul>
<li><a href="archives/archive.zip">archive.zip</a></li>
</ul>

        </div>
      
    </div>
  </div>
</div>

<script>
  $(document).on('keydown', function(e) {
  e = e || window.event;
  var nextTab;
  switch (e.which || e.keyCode) {
    case 37: // left
      nextTab = $('.tab-menu a[data-tab].active').prev('a[data-tab]');
      if (!nextTab.length) nextTab = $('.tab-menu a[data-tab]').last();
      nextTab.click();
      $('.pusher').focus();
      break;

    case 39: // right
      nextTab = $('.tab-menu a[data-tab].active').next('a[data-tab]');
      if (!nextTab.length) nextTab = $('.tab-menu a[data-tab]').first();
      nextTab.click();
      $('.pusher').focus();
      break;
  }
});

  $(document).ready(function() {
  $('img').addClass('ui image');

  $('.ui.embed').embed();

  const $images = $('.lab img');
  jQuery.each($images, function(i) {
    if ($images[i].alt.length > 0) {
      const divImg = $(document.createElement('div')).addClass(
        'ui basic segment',
      );
      $($images[i]).wrap(divImg);
      const divLabel = $(document.createElement('div')).addClass(
        'ui blue ribbon label',
      );
      divLabel.append($images[i].alt);
      $(divLabel).insertBefore($images[i]);
    }
  });

  $('.ui.menu .item').tab({
    history: true,
    historyType: 'hash',
  });

  $('.popup').popup();

  $('.ui.sidebar')
    .sidebar({ context: $('.pushable') })
    .sidebar('setting', 'transition', 'slide out')
    .sidebar('attach events', '#toc');
});

</script>
</body>
</html>